## Классические алгоритмы для создания картин по номерам

Здесь я постараюсь написать классические алгоритмы 
(без использования ml), которые будут создавать картины 
по номерам. 

## Зависимости, которые нужно установить

Я пишу код на версии Python 3.12 и использую библиотеки, которые работают
с ней.

Зависимости можно установить с помощью requirements.txt:
```commandline
pip install -r requirements.txt --upgrade
```

## Модули, которые использую

### Pillow

Основной модуль для работы с изображениями. Используется в модуле 1

### matplotlib

По сути не нужен в проекте (как мне кажется), но использовать
для отладки интересно, так что пока добавлю.

Функцию для отрисовки изображений через matplotlib разместил в 
**utils/show_image.py**.

### cv2

```
pip install opencv-python
```

cv2 — интерфейс Python для библиотеки OpenCV (Open Source Computer Vision Library), 
предназначенной для задач компьютерного зрения, машинного обучения и обработки изображений.

В модуле 2 используется для перевода из цветового пространства RGB в цветовое пространство CIELAB

## Комментарии к модулям:

### 1. preprocessing

Предобработка нужна для последующего анализа изображения

Этапы:

1. Загрузка изображения
2. Масштабирование изображения
3. Фильтрация изображения
4. Перевод в numpy array

### 2. quanting

Выполняет цветовое квантование. По сути сводит изображение к 
ограниченному набору цветов.

Для квантования будем использовать алгоритм 
[k-means](https://habr.com/ru/companies/skillfactory/articles/877684/). Прочитать внимательно,
он простой, но пока я писал модуль 2 с нейронкой (qwen), очень много её поправлял, потому что она
часто делала лишние действия при работе с данным алгоритмом. 

По сути алгоритм k-means работает на координатах точек и их расстояниях (евклидово расстояние,
буквально теорема Пифагора, но для сколько угодно больших измерений).

Цвета часто записываются 3-мя числами, например в RGB (0-255; 0-255; 0-255). По сути это точка с
тремя координатами X, Y, Z. В таком случае k-means просто будет делить трёхмерное пространство 
(я представляю это как цетральные точки и сферы, в которые попадают соседи)

Есть небольшая проблемка: человеческий глаз различает нелинейно. Подробнее об этом можно посмотреть readme
в **utils/differences_in_color_spaces**.

Сейчас в качестве цветового пространства выберем CIELAB.

Этапы:

1. Перевести изображение в CIELAB
2. Отмасштабировать признаки для k-means (тут нужно будет внимательно проверить всё, но потом)
3. Провести кластеризацию
4. Заменим все пиксели новыми цветами (центром их кластера)
5. Переведём обратно в RGB (возможно рано)


