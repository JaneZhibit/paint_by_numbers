# Классические алгоритмы для создания картин по номерам

Здесь я постараюсь написать классические алгоритмы 
(без использования ml), которые будут создавать картины 
по номерам. 

***

# Зависимости, которые нужно установить

Я пишу код на версии Python 3.12 и использую библиотеки, которые работают
с ней.

Зависимости можно установить с помощью requirements.txt:
```commandline
pip install -r requirements.txt --upgrade
```

***

# Модули, которые использую

## Pillow

Основной модуль для работы с изображениями. Используется в модуле 1

## matplotlib

По сути не нужен в проекте (как мне кажется), но использовать
для отладки интересно, так что пока добавлю.

Функцию для отрисовки изображений через matplotlib разместил в 
**utils/show_image.py**.

## cv2

```
pip install opencv-python
```

cv2 — интерфейс Python для библиотеки OpenCV (Open Source Computer Vision Library), 
предназначенной для задач компьютерного зрения, машинного обучения и обработки изображений.

В модуле 2 используется для перевода из цветового пространства RGB в цветовое пространство CIELAB

***

# Класс ClassicalPaintByNumbers

Это класс генератор. Каждый объект - картина, которую мы хотим создать.

Для удобства чтения разбит на удобные функции, каждая из которых занимается своим делом. Переменные, которые нужно
использовать в нескольких функциях определены в **init**. Так как они являются самыми важными составляющими, я дал к ним
отдельные комментарии.

***

## Инициализация init

Вызывается при создании объекта класса.

### В качестве аргумента принимает словарь:

```
{
  "img_path": "test_img.webp",      # <- путь к изображению
  "target_max_side": 1000,          # <- максимальная длина стороны в пикселях
  'canvas_width_mm': 400,           # <- ширина холста в мм
  'canvas_height_mm': 300,          # <- высота холста в мм
  'min_diameter_mm': 5,             # <- диаметр кисти (наименьшей) в мм
  'colours_cnt': 12,                # <- количество цветов для кластеризации
  'logging': True                   # <- показать/скрыть вывод из print()
}
```

***

### Промежуточные данные в init:

***

#### self.original_img 
изображение, загруженное с диска до изменений

Хранится в формате PIL.Image.Image

***

#### self.preprocessed_img 
изображение, прошедшее этапы предобработки:
* загрузка с диска
* масштабирование до нужного размера
* сглаживание через медианный фильтр
    
Хранится в формате numpy.ndarray (numpy-массив).

Размерность (shape): (высота, ширина, 3)
* высота - количество пикселей по вертикали
* ширина - количество пикселей по горизонтали
* 3 - цветовых канала (R, G, B)

***
#### self.quant_rgb
изображение после квантования (уменьшенное кол-во цветов)

Тип данных: numpy.ndarray - такой же, как preprocessed_img

Размерность (shape): (высота, ширина, 3)

***
#### self.quant_lab

Тип данных: numpy.ndarray - как и все остальные изображения

Размерность: (высота, ширина, 3) - те же размеры, что у quant_rgb

Три канала теперь означают:

* [:, :, 0] - L (Lightness) — яркость, от 0 до 100 (возможно правильно было оставить 0-255)
* [:, :, 1] - a (зеленый-красный) — примерно от 0 до 256
* [:, :, 2] - b (синий-желтый) — примерно от 0 до 256

*** 
#### self.cluster_centers_lab
Цвета, которые алгоритм выбрал для картины.

Тип данных: numpy.ndarray

Размерность: (K, 3) где:
* K - количество цветов/кластеров (например, 12)
* 3 - каналы L, a, b

*** 
#### self.cluster_labels
карта, где каждому пикселю присвоен номер краски (из cluster_centers_lab)

Тип данных: numpy.ndarray

Размерность: (высота, ширина)

***

## validate_config

Проверяет, что все параметры config были переданы

***

## 1. preprocessing

Предобработка нужна для последующего анализа изображения

Этапы:

1. Загрузка изображения
2. Масштабирование изображения (максимальный размер стороны 1000 пикселей)
3. Фильтрация изображения
4. Перевод в numpy array

***

## 2. quanting

Выполняет цветовое квантование. По сути сводит изображение к 
ограниченному набору цветов.

Для квантования будем использовать алгоритм 
[k-means](https://habr.com/ru/companies/skillfactory/articles/877684/). Прочитать внимательно,
он простой, но пока я писал модуль 2 с нейронкой (qwen), очень много её поправлял, потому что она
часто делала лишние действия при работе с данным алгоритмом. 

По сути алгоритм k-means работает на координатах точек и их расстояниях (евклидово расстояние,
буквально теорема Пифагора, но для сколько угодно больших измерений).

Цвета часто записываются 3-мя числами, например в RGB (0-255; 0-255; 0-255). По сути это точка с
тремя координатами X, Y, Z. В таком случае k-means просто будет делить трёхмерное пространство 
(я представляю это как цетральные точки и сферы, в которые попадают соседи)

Есть небольшая проблемка: человеческий глаз различает нелинейно. Подробнее об этом можно посмотреть readme
в **utils/differences_in_color_spaces**.

Сейчас в качестве цветового пространства выберем CIELAB.

Этапы:

1. Перевести изображение в CIELAB
2. Отмасштабировать признаки для k-means (тут нужно будет внимательно проверить всё, но потом)
3. Провести кластеризацию
4. Заменим все пиксели новыми цветами (центром их кластера)
5. Переведём обратно в RGB (возможно рано)

***

## 3. postprocessing

В этом модуле я хочу удалить незакрашиваемые области, если такие присутствуют.
Незакрашиваемыми я называю те, размер которых слишком маленький. Я хочу ввести
минимальный размер области, которую комфортно закрашивать. 

На комфорт влияют физические факторы:

- размер самой маленькой кисти в наборе
- размер самого холста 

Поскольку мы не обрезали изображения по нужному размеру всё будет немного криво
и с оговорками, но работать. Главное запомнить, что обрезка по масштабу должна производиться заранее.

Алгоритм будет не совсем идеальным. Мы высчитаем минимальную закрашиваемую площадь региона в квадратных мм.
Мы можем узнать площадь региона (одного цвета) на изображении с помощью cv2.connectedComponents. Это быстрая операция.
Другой анализ форм сложнее в реализации и по дольше вычисляется. Сейчас я решил использовать быстрый способ, который
сможет отфильтровать откровенный шлак. Такая постобработка не справится с фильтрацией тонких линий (площадь достаточна,
но закрашивать сложно).

